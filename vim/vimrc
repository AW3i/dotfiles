let vimpath = '$HOME/.vim/'
if has('nvim')
    let vimpath = '$HOME/.config/nvim/'
endif

" Auto Installs vim-plugged if it doesn't exist
if empty(glob(vimpath . 'autoload/plug.vim'))
    exec 'silent' '!' 'curl -fLo' . vimpath . 'autoload/plug.vim --create-dirs  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    silent !curl -fLo vimpath . 'autoload/plug.vim' --create-dirs
    autocmd VimEnter * PlugInstall
endif

set backspace=indent,eol,start
set history=1000
set showcmd
set incsearch
set hlsearch
set wrap
set linebreak
set laststatus=2

set tabstop=4
set expandtab
set smarttab
set shiftwidth=4
set shiftround
set matchpairs+=<:>

set scrolloff=10
set sidescrolloff=7
set sidescroll=1

syntax on
set showmatch
set hidden
set noautowrite
set more
set noshowmode
set nostartofline
set wildmenu
set lazyredraw
set shell=zsh
set number
set relativenumber
set iskeyword+=_,$,@,%,#
set splitbelow
set splitright
set undolevels=500
if has("persistent_undo")
    set undofile
endif
set timeout timeoutlen=1000 ttimeoutlen=100
set list listchars=tab:»·,trail:·,extends:»,precedes:«
set encoding=utf-8
scriptencoding utf-8
set complete+=i,kspell
set omnifunc=syntaxcomplete#Complete
set wildignore+=*.bmp,*.gif,*.jpg,*.png,*.ico
set wildignore+=*.swp,*.tmp
if executable('rg')
    set grepprg=rg\ --vimgrep\ --no-ignore\ --no-heading\ --smart-case
endif

let &showbreak='↪ '
let mapleader = " "
let maplocalleader = "\\"
set title
set noequalalways
if exists('&inccommand')
  set inccommand=split
endif
set nomodeline

filetype plugin indent  on
filetype off

highlight! ErrorSign guifg=black guibg=#E01600 ctermfg=16 ctermbg=160
highlight! WarningSign guifg=black guibg=#FFED26 ctermfg=16 ctermbg=11

" Use a blinking upright bar cursor in Insert mode, a solid block in normal
" and a blinking underline in replace mode
set guicursor=n-v-c:block-Cursor/lCursor-blinkon0,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor
"enable mouse support
set mouse=a

call plug#begin(vimpath. 'plugged')
" Plug 'Raimondi/delimitMate'
"     let delimitMate_jump_expansion = 1
"     let delimitMate_expand_cr = 2
"     let delimitMate_expand_space = 0
Plug 'tmsvg/pear-tree'
Plug 'tpope/vim-obsession'
Plug 'kana/vim-operator-replace'
Plug 'kana/vim-operator-user'
Plug 'tommcdo/vim-exchange'
Plug 'dhruvasagar/vim-prosession'
Plug 'rhysd/vim-grammarous'
Plug 'mechatroner/rainbow_csv'
autocmd BufNewFile,BufRead *.csv   set filetype=csv_semicolon
Plug 'swekaj/php-foldexpr.vim'
Plug 'tommcdo/vim-lion'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'
Plug 'tomtom/tcomment_vim'
Plug 'tpope/vim-abolish'
if has('python')
    Plug 'SirVer/UltiSnips' | Plug 'honza/vim-snippets'
        let g:UltiSnipsExpandTrigger = "<tab>"
        let g:UltiSnipsJumpForwardTrigger = "<tab>"
        let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"
        let g:UltiSnipsUsePythonVersion = 3
        let g:UltiSnipsEditSplit="vertical"
        let g:UltiSnipsSnippetDirectories = ['~/.config/nvim/UltiSnips', 'UltiSnips']
        let g:snips_author = 'Alexandros Weigl'
        if !exists("g:snips_company")
            let g:snips_company = 'TechDivison'
        endif
        if !exists("g:snips_username")
            let g:snips_username = 'AW3i'
        endif
endif
" Readline bindings
Plug 'tpope/vim-rsi'
Plug 'wellle/targets.vim'
" Star search
Plug 'pgdouyon/vim-evanesco'
Plug 'janko-m/vim-test'
    let test#strategy = "neoterm"
Plug 'mbbill/undotree', {'on': 'UndotreeToggle'}
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-eunuch'
Plug 'dansomething/vim-hackernews', {'on': 'HackerNews'}
Plug 'neomake/neomake'
    let g:neomake_php_phpcs_args_standard = 'src/vendor/magento/magento-coding-standard/Magento2/ruleset.xml'
    let g:neomake_php_enabled_makers = ['php', 'phpcs', 'psalm']
Plug 'rhysd/git-messenger.vim'

Plug 'justinmk/vim-sneak'
    let g:sneak#label = 1
Plug 'justinmk/vim-dirvish'
    augroup my_dirvish_events
      autocmd!
      " Map t to "open in new tab".
      autocmd FileType dirvish
        \  nnoremap <buffer> t :call dirvish#open('tabedit', 0)<CR>
        \ |xnoremap <buffer> t :call dirvish#open('tabedit', 0)<CR>

      " Enable :Gstatus and friends.
      autocmd FileType dirvish call fugitive#detect(@%)

      " Map CTRL-R to reload the Dirvish buffer.
      autocmd FileType dirvish nnoremap <buffer> <C-R> :<C-U>Dirvish %<CR>

      " Map `gh` to hide dot-prefixed files.
      " To "toggle" this, just press `R` to reload.
      autocmd FileType dirvish nnoremap <buffer>
        \ gh :keeppatterns g@\v/\.[^\/]+/?$@d<cr>
    augroup END
Plug 'kassio/neoterm'
    let g:neoterm_default_mod = 'botright'
    let g:neoterm_automap_keys = '<leader>tm'
    let g:neoterm_use_relative_path = 1
    let g:neoterm_autoscroll = 1
    let g:neoterm_always_open_to_exec = 0
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
    let g:fzf_nvim_statusline = 0 " disable statusline overwriting
    let g:fzf_files_options =
      \ '--preview "(highlight -O ansi {} || cat {}) 2> /dev/null | head -'.&lines.'"'

    function! SearchWordWithAg()
        execute 'Ag' expand('<cword>')
    endfunction

    function! SearchWordWithAgi()
        execute 'Agi' expand('<cword>')
    endfunction

    function! SearchVisualSelectionWithAg() range
        let old_reg = getreg('"')
        let old_regtype = getregtype('"')
        let old_clipboard = &clipboard
        set clipboard&
        normal! ""gvy
        let selection = getreg('"')
        call setreg('"', old_reg, old_regtype)
        let &clipboard = old_clipboard
        execute 'Ag' selection
    endfunction

    function! SearchVisualSelectionWithAgi() range
        let old_reg = getreg('"')
        let old_regtype = getregtype('"')
        let old_clipboard = &clipboard
        set clipboard&
        normal! ""gvy
        let selection = getreg('"')
        call setreg('"', old_reg, old_regtype)
        let &clipboard = old_clipboard
        execute 'Agj' selection
    endfunction


    function! s:ag_to_qf(line)
        let parts = split(a:line, ':')
        return {'filename': parts[0], 'lnum': parts[1], 'col': parts[2],
        \ 'text': join(parts[3:], ':')}
    endfunction

    function! s:ag_handler(lines)
        if len(a:lines) < 2 | return | endif

        let cmd = get({'ctrl-x': 'split',
        \ 'ctrl-v': 'vertical split',
        \ 'ctrl-t': 'tabe'}, a:lines[0], 'e')
        let list = map(a:lines[1:], 's:ag_to_qf(v:val)')

        let first = list[0]
        execute cmd escape(first.filename, ' %#\')
        execute first.lnum
        execute 'normal!' first.col.'|zz'

        if len(list) > 1
            call setqflist(list)
            copen
        wincmd p endif
    endfunction

    command! -nargs=* Ag call fzf#run({
    \ 'source':  printf('rg --column --color always "%s"',
    \                   escape(empty(<q-args>) ? '^(?=.)' : <q-args>, '"\')),
    \ 'sink*':    function('<sid>ag_handler'),
    \ 'options': "--ansi --expect=ctrl-t,ctrl-v,ctrl-x --delimiter : --nth 4.. "
    \ })

    command! -nargs=* Agi call fzf#run({
    \ 'source':  printf('rg --no-ignore --column --color always "%s"',
    \                   escape(empty(<q-args>) ? '^(?=.)' : <q-args>, '"\')),
    \ 'sink*':    function('<sid>ag_handler'),
    \ 'options': "--ansi --expect=ctrl-t,ctrl-v,ctrl-x --delimiter : --nth 4.. "
    \ })

    let g:fzf_colors =
    \ { 'fg':      ['fg', 'Normal'],
      \ 'bg':      ['bg', 'Normal'],
      \ 'hl':      ['fg', 'Comment'],
      \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
      \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
      \ 'hl+':     ['fg', 'Statement'],
      \ 'info':    ['fg', 'PreProc'],
      \ 'border':  ['fg', 'Ignore'],
      \ 'prompt':  ['fg', 'Conditional'],
      \ 'pointer': ['fg', 'Exception'],
      \ 'marker':  ['fg', 'Keyword'],
      \ 'spinner': ['fg', 'Label'],
      \ 'header':  ['fg', 'Comment'] }

Plug 'Konfekt/Fastfold'
Plug 'AndrewRadev/tagalong.vim'
    let g:tagalong_additional_filetypes = ['phtml', 'twig', 'dhtml']

" Appearance
Plug 'itchyny/lightline.vim'
    let g:lightline = {
        \   'colorscheme': 'one',
        \   'active': {
        \     'left': [
        \       ['mode', 'paste'],
        \       ['fugitive', 'bufferinfo'],
        \     ],
        \     'right': [
        \       ['colinfo', 'percent'],
        \       ['fileformat', 'filetype'],
        \     ]
        \   },
        \   'inactive': {
        \     'left': [ ['bufferinfo'] ],
        \     'right': [ ['percent'], ['filetype'] ]
        \   },
        \   'tabline': {
        \     'left': [ ['tabs'], ['bufferline'] ],
        \     'right': [ ['fileencoding'] ]
        \   },
        \   'component': {
        \     'bufferinfo': '%<%f %m',
        \     'colinfo': ':%c%V',
        \     'fileencoding': '%{&fenc}',
        \     'readonly': '%{&readonly?"":""}',
        \     'paste': '%{&paste?"PASTE":""}',
        \   },
        \   'component_function': {
        \     'fileformat'  : 'MyFileformat',
        \     'filetype'    : 'MyFiletype',
        \     'fugitive'    : 'MyFugitive'
        \   },
        \   'separator': { 'left': '', 'right': '' },
        \   'subseparator': { 'left': '', 'right': '' },
        \ }

    let g:lightline.enable = {
        \   'statusline': 1,
        \   'tabline': 1
        \ }

    let g:lightline.mode_map = {
        \   'n'      : ' N ',
        \   'i'      : ' I ',
        \   'R'      : ' R ',
        \   'v'      : ' V ',
        \   'V'      : 'V-L',
        \   'c'      : ' C ',
        \   "\<C-v>" : 'V-B',
        \   's'      : ' S ',
        \   'S'      : 'S-L',
        \   "\<C-s>" : 'S-B',
        \   "t"      : ' T ',
        \   '?'      : ' ? '
        \ }

    function! MyFiletype()
    return strlen(&filetype) ? &filetype : '--'
    endfunction

    function! MyFileformat()
    return winwidth('.') > 80 ? &fileformat : ''
    endfunction

    function! MyFugitive()
    if exists('*fugitive#head') && winwidth('.') > 75
        let bmark = '┣ '
        let branch = fugitive#head()
        return strlen(branch) ? bmark . branch : ''
    endif
    return ''
    endfunction
Plug 'troydm/zoomwintab.vim'
Plug 'romainl/vim-qf'
Plug 'AndrewRadev/splitjoin.vim'
    let g:splitjoin_php_method_chain_full = 1
Plug 'moll/vim-bbye'
Plug 'yuttie/comfortable-motion.vim'
"
Plug 'rakr/vim-one'
    let g:one_allow_italics = 1 
" VCS
Plug 'tpope/vim-fugitive'
Plug 'mhinz/vim-signify'

" Languages
if has('nvim')
    Plug 'ncm2/ncm2' | Plug 'roxma/nvim-yarp'| Plug 'ncm2/ncm2-bufword' | Plug 'ncm2/ncm2-path' | Plug 'ncm2/ncm2-ultisnips' | Plug 'ncm2/ncm2-tern',  {'for': 'js', 'do': 'npm install'} | Plug 'phpactor/ncm2-phpactor', {'for': 'php'} | Plug 'pbogut/ncm2-alchemist'
    " enable ncm2 for all buffers
    autocmd BufEnter * call ncm2#enable_for_buffer()
    " suppress the annoying 'match x of y', 'The only match' and 'Pattern not
    " found' messages
    set shortmess+=c
    " :help Ncm2PopupOpen for more information
    set completeopt=noinsert,menuone,noselect
        " some completion sources
endif
Plug 'Shougo/echodoc.vim'
    let g:echodoc_enable_at_startup = 1
Plug 'vim-vdebug/vdebug'
    if !exists('g:vdebug_options')
      let g:vdebug_options = {}
    endif
    let g:vdebug_options.break_on_open = 0
    let g:vdebug_options.ide_key = 'PHPSTORM'
Plug 'sheerun/vim-polyglot'
    let g:polyglot_disabled = ['latex']
Plug 'sgur/vim-editorconfig'
Plug 'andymass/vim-matchup'
Plug 'mattn/emmet-vim'
    let g:user_emmet_install_global = 0
Plug 'lervag/vimtex', {'for': 'tex'}

Plug 'tobyS/pdv', {'for': 'php'} | Plug 'tobyS/vmustache', {'for': 'php'}
    let g:pdv_template_dir = $HOME . "/Documents/git/dotfiles/vim/plugged/pdv/templates_snip"
Plug 'phpactor/phpactor', {'branch': 'develop', 'for': 'php', 'do': 'composer install'}
    let g:phpactorInputListStrategy = 'fzf'
Plug 'slashmili/alchemist.vim', {'for': 'elixir'}
call plug#end()
"
" When writing a buffer (no delay).
call neomake#configure#automake('w')
" When writing a buffer (no delay), and on normal mode changes (after 750ms).
call neomake#configure#automake('nw', 750)
" When reading a buffer (after 1s), and when writing (no delay).
call neomake#configure#automake('rw', 1000)
" Full config: when writing or reading a buffer, and on changes in insert and
" normal mode (after 1s; no delay when writing).
call neomake#configure#automake('nrwi', 500)

if (has("termguicolors"))
    set termguicolors
endif
" colorscheme hybrid_reverse
colorscheme one
set background=dark

" nnoremap <silent> <leader>bc :bp<bar>sp<bar>bn<bar>bd<CR>
nnoremap <silent> <leader>bd :Bdelete<CR>
nnoremap <silent> <leader>bw :Bwipeout<CR>
nnoremap <silent> <leader>tn :tabnew<CR>
" Switch back to normal mode from terminal mode
if has('nvim')
    tnoremap <esc><esc> <C-\><C-n>
    nnoremap  <leader>tv :vs +te<CR>
    nnoremap  <leader>ts :sp +te<CR>
endif

" Keep search results at the center of screen
nmap n nzz
nmap N Nzz
nmap * *zz
nmap # #zz
nmap g* g*zz
nmap g# g#zz

" Store relative line number jumps in the jumplist.
nnoremap <expr> k (v:count > 1 ? "m'" . v:count : '') . 'k'
nnoremap <expr> j (v:count > 1 ? "m'" . v:count : '') . 'j'

" sneak
"replace 'f' with 1-char Sneak
nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
xmap f <Plug>Sneak_f
xmap F <Plug>Sneak_F
omap f <Plug>Sneak_f
omap F <Plug>Sneak_F
"replace 't' with 1-char Sneak
nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
xmap t <Plug>Sneak_t
xmap T <Plug>Sneak_T
omap t <Plug>Sneak_t
omap T <Plug>Sneak_T

" neoterm
xmap <leader>tr <plug>(neoterm-repl-send)
nmap <leader>trl <plug>(neoterm-repl-send-line)

nnoremap <leader>tr :T 
" Rerun last command
nnoremap <silent> <leader>tR :<c-u>exec printf("%sTexec !! \<lt>cr>", v:count)<cr>
nnoremap <silent> <leader>tt :<c-u>exec printf('%sTtoggle', v:count)<cr>
nnoremap <silent> <leader>vt :<c-u>exec printf('botright vertical %s Ttoggle', v:count)<cr>
nnoremap <silent> <leader>te :<c-u>exec printf('%sT exit', v:count)<cr>
nnoremap <silent> <leader>tl :<c-u>exec printf('%sTclear', v:count)<cr>
nnoremap <silent> <leader>tk :<c-u>exec printf('%sTkill', v:count)<cr>

" fzf
nnoremap <silent> <leader><space> :Files<CR>
nnoremap <silent> <leader>a :Buffers<CR>
nnoremap <silent> <leader>; :BLines<CR>
nnoremap <silent> <leader>. :Lines<CR>
" nnoremap <silent> <leader>o :BTags<CR>
" nnoremap <silent> <leader>O :Tags<CR>
nnoremap <silent> <leader>h :History<CR>
nnoremap <silent> <leader>, :execute 'Agi ' . input('Ag/')<CR>
nnoremap <silent> <leader>/ :execute 'Ag ' . input('Ag/')<CR>
nnoremap <silent> K :call SearchWordWithAg()<CR>
nnoremap <silent> Ki :call SearchWordWithAgi()<CR>
vnoremap <silent> K :call SearchVisualSelectionWithAg()<CR>
vnoremap <silent> Ki :call SearchVisualSelectionWithAgi()<CR>
nnoremap <silent> <leader>gl :Commits<CR>
nnoremap <silent> <leader>ga :BCommits<CR>
nnoremap <silent> <leader>w :Windows<CR>
inoremap <silent> <C-s> <ESC>:Snippets<CR>
nnoremap <silent> <leader>m :Mru<CR>

imap <C-x><C-f> <plug>(fzf-complete-file-ag)
imap <C-x><C-l> <plug>(fzf-complete-line)

" fugitive mappings
function! ToggleGStatus()
    if buflisted(bufname('.git/index'))
        bd .git/index
    else
        Gstatus
    endif
endfunction
command ToggleGStatus :call ToggleGStatus()
nnoremap <leader>ga :Gwrite<CR>
nnoremap <leader>gs :ToggleGStatus<CR>
nnoremap <leader>gd :Gdiff<CR>
nnoremap <leader>gc :Gcommit<CR>
nnoremap <leader>gb :Git branch<Space>

" Others
autocmd FileType php nnoremap <C-p> :call pdv#DocumentWithSnip()<CR>
nnoremap <silent> <F1>  :UndotreeToggle<CR>

" Include use statement
autocmd FileType php nmap <Leader>u :call phpactor#UseAdd()<CR>
" Invoke the context menu
autocmd FileType php nmap <Leader>mm :call phpactor#ContextMenu()<CR>
" Goto definition of class or class member under the cursor
autocmd FileType php nmap <Leader>oo :call phpactor#GotoDefinition()<CR>
autocmd FileType php nmap <Leader>oh :call phpactor#GotoDefinitionHsplit()<CR>
autocmd FileType php nmap <Leader>ov :call phpactor#GotoDefinitionVsplit()<CR>
autocmd FileType php nmap <Leader>ot :call phpactor#GotoDefinitionTab()<CR>
autocmd FileType php nmap <Leader>na :call phpactor#Navigate()<CR>
" Transform the classes in the current file
autocmd FileType php nmap <Leader>pt :call phpactor#Transform()<CR>
" Display information
autocmd FileType php nmap <Leader>h :call phpactor#Hover()<CR>
" Generate a new class (replacing the current file)
autocmd FileType php nmap <Leader>cc :call phpactor#ClassNew()<CR>
" Extract expressoins
autocmd FileType php nmap <Leader>ee :call phpactor#ExtractExpression(v:false)<CR>
autocmd FileType php vmap <silent><Leader>em :<C-U>call phpactor#ExtractExpression(v:true)<CR>
"Extract interface
autocmd FileType php nmap <Leader>ei :call phpactor#ClassInflect()<CR>
autocmd FileType php nmap <Leader>fr :call phpactor#FindReferences()<CR>
" Extract method from selection
autocmd FileType php vmap <silent><Leader>em :<C-U>call phpactor#ExtractMethod()<CR>
" Ale
nmap <silent> <C-k> <Plug>(ale_previous_wrap)
nmap <silent> <C-j> <Plug>(ale_next_wrap)

function! PhpSyntaxOverride()
  hi! def link phpDocTags  phpDefine
  hi! def link phpDocParam phpType
endfunction

augroup phpSyntaxOverride
  autocmd!
  autocmd FileType php call PhpSyntaxOverride()
augroup END
autocmd BufWritePost *.exs,*.ex silent :!mix format %
autocmd BufNewFile,BufRead *.phtml setf php
autocmd BufNewFile,BufRead *.dhtml setf php
autocmd FileType mail set spell
